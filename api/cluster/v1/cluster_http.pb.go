// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// protoc-gen-go-http v2.2.2

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

type ClusterHTTPServer interface {
	CompareCluster(context.Context, *ClusterCompareRequest) (*ClusterCompareReply, error)
	CreateCluster(context.Context, *ClusterCreateRequest) (*ClusterCreateReply, error)
	DeleteCluster(context.Context, *ClusterDeleteRequest) (*ClusterDeleteReply, error)
	GetCluster(context.Context, *ClusterRequest) (*ClusterReply, error)
	ListCluster(context.Context, *ClusterListRequest) (*ClusterListReply, error)
	LogCluster(context.Context, *ClusterLogRequest) (*ClusterLogReply, error)
	ManagedCluster(context.Context, *ClusterManagedRequest) (*ClusterManagedReply, error)
	UpdateCluster(context.Context, *ClusterUpdateRequest) (*ClusterUpdateReply, error)
}

func RegisterClusterHTTPServer(s *http.Server, srv ClusterHTTPServer) {
	r := s.Route("/")
	r.GET("/api/v1/clusters/{cluster_id}", _Cluster_GetCluster0_HTTP_Handler(srv))
	r.GET("/api/v1/clusters", _Cluster_ListCluster0_HTTP_Handler(srv))
	r.POST("/api/v1/clusters", _Cluster_CreateCluster0_HTTP_Handler(srv))
	r.PUT("/api/v1/clusters", _Cluster_UpdateCluster0_HTTP_Handler(srv))
	r.DELETE("/api/v1/clusters/{cluster_id}", _Cluster_DeleteCluster0_HTTP_Handler(srv))
	r.POST("/api/v1/clusters/managed", _Cluster_ManagedCluster0_HTTP_Handler(srv))
	r.GET("/api/v1/clusters/{cluster_id}/log", _Cluster_LogCluster0_HTTP_Handler(srv))
	r.POST("/api/v1/clusters/{cluster_id}/compare", _Cluster_CompareCluster0_HTTP_Handler(srv))
}

func _Cluster_GetCluster0_HTTP_Handler(srv ClusterHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ClusterRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/cluster.v1.Cluster/GetCluster")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetCluster(ctx, req.(*ClusterRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ClusterReply)
		return ctx.Result(200, reply)
	}
}

func _Cluster_ListCluster0_HTTP_Handler(srv ClusterHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ClusterListRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/cluster.v1.Cluster/ListCluster")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListCluster(ctx, req.(*ClusterListRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ClusterListReply)
		return ctx.Result(200, reply)
	}
}

func _Cluster_CreateCluster0_HTTP_Handler(srv ClusterHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ClusterCreateRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/cluster.v1.Cluster/CreateCluster")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateCluster(ctx, req.(*ClusterCreateRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ClusterCreateReply)
		return ctx.Result(200, reply)
	}
}

func _Cluster_UpdateCluster0_HTTP_Handler(srv ClusterHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ClusterUpdateRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/cluster.v1.Cluster/UpdateCluster")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateCluster(ctx, req.(*ClusterUpdateRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ClusterUpdateReply)
		return ctx.Result(200, reply)
	}
}

func _Cluster_DeleteCluster0_HTTP_Handler(srv ClusterHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ClusterDeleteRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/cluster.v1.Cluster/DeleteCluster")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteCluster(ctx, req.(*ClusterDeleteRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ClusterDeleteReply)
		return ctx.Result(200, reply)
	}
}

func _Cluster_ManagedCluster0_HTTP_Handler(srv ClusterHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ClusterManagedRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/cluster.v1.Cluster/ManagedCluster")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ManagedCluster(ctx, req.(*ClusterManagedRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ClusterManagedReply)
		return ctx.Result(200, reply)
	}
}

func _Cluster_LogCluster0_HTTP_Handler(srv ClusterHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ClusterLogRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/cluster.v1.Cluster/LogCluster")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.LogCluster(ctx, req.(*ClusterLogRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ClusterLogReply)
		return ctx.Result(200, reply)
	}
}

func _Cluster_CompareCluster0_HTTP_Handler(srv ClusterHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ClusterCompareRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/cluster.v1.Cluster/CompareCluster")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CompareCluster(ctx, req.(*ClusterCompareRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ClusterCompareReply)
		return ctx.Result(200, reply)
	}
}

type ClusterHTTPClient interface {
	CompareCluster(ctx context.Context, req *ClusterCompareRequest, opts ...http.CallOption) (rsp *ClusterCompareReply, err error)
	CreateCluster(ctx context.Context, req *ClusterCreateRequest, opts ...http.CallOption) (rsp *ClusterCreateReply, err error)
	DeleteCluster(ctx context.Context, req *ClusterDeleteRequest, opts ...http.CallOption) (rsp *ClusterDeleteReply, err error)
	GetCluster(ctx context.Context, req *ClusterRequest, opts ...http.CallOption) (rsp *ClusterReply, err error)
	ListCluster(ctx context.Context, req *ClusterListRequest, opts ...http.CallOption) (rsp *ClusterListReply, err error)
	LogCluster(ctx context.Context, req *ClusterLogRequest, opts ...http.CallOption) (rsp *ClusterLogReply, err error)
	ManagedCluster(ctx context.Context, req *ClusterManagedRequest, opts ...http.CallOption) (rsp *ClusterManagedReply, err error)
	UpdateCluster(ctx context.Context, req *ClusterUpdateRequest, opts ...http.CallOption) (rsp *ClusterUpdateReply, err error)
}

type ClusterHTTPClientImpl struct {
	cc *http.Client
}

func NewClusterHTTPClient(client *http.Client) ClusterHTTPClient {
	return &ClusterHTTPClientImpl{client}
}

func (c *ClusterHTTPClientImpl) CompareCluster(ctx context.Context, in *ClusterCompareRequest, opts ...http.CallOption) (*ClusterCompareReply, error) {
	var out ClusterCompareReply
	pattern := "/api/v1/clusters/{cluster_id}/compare"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/cluster.v1.Cluster/CompareCluster"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ClusterHTTPClientImpl) CreateCluster(ctx context.Context, in *ClusterCreateRequest, opts ...http.CallOption) (*ClusterCreateReply, error) {
	var out ClusterCreateReply
	pattern := "/api/v1/clusters"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/cluster.v1.Cluster/CreateCluster"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ClusterHTTPClientImpl) DeleteCluster(ctx context.Context, in *ClusterDeleteRequest, opts ...http.CallOption) (*ClusterDeleteReply, error) {
	var out ClusterDeleteReply
	pattern := "/api/v1/clusters/{cluster_id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/cluster.v1.Cluster/DeleteCluster"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ClusterHTTPClientImpl) GetCluster(ctx context.Context, in *ClusterRequest, opts ...http.CallOption) (*ClusterReply, error) {
	var out ClusterReply
	pattern := "/api/v1/clusters/{cluster_id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/cluster.v1.Cluster/GetCluster"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ClusterHTTPClientImpl) ListCluster(ctx context.Context, in *ClusterListRequest, opts ...http.CallOption) (*ClusterListReply, error) {
	var out ClusterListReply
	pattern := "/api/v1/clusters"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/cluster.v1.Cluster/ListCluster"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ClusterHTTPClientImpl) LogCluster(ctx context.Context, in *ClusterLogRequest, opts ...http.CallOption) (*ClusterLogReply, error) {
	var out ClusterLogReply
	pattern := "/api/v1/clusters/{cluster_id}/log"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/cluster.v1.Cluster/LogCluster"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ClusterHTTPClientImpl) ManagedCluster(ctx context.Context, in *ClusterManagedRequest, opts ...http.CallOption) (*ClusterManagedReply, error) {
	var out ClusterManagedReply
	pattern := "/api/v1/clusters/managed"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/cluster.v1.Cluster/ManagedCluster"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ClusterHTTPClientImpl) UpdateCluster(ctx context.Context, in *ClusterUpdateRequest, opts ...http.CallOption) (*ClusterUpdateReply, error) {
	var out ClusterUpdateReply
	pattern := "/api/v1/clusters"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/cluster.v1.Cluster/UpdateCluster"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
